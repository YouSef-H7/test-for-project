name: Build & Deploy to AKS

on:
  push:
    branches:
      - main
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'k8s/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

env:
  # Azure Resources
  RESOURCE_GROUP: error-team-rg
  ACR_NAME: acrteam4
  AKS_CLUSTER_NAME: aks-cluster-team4
  AKS_NAMESPACE: app
  
  # Docker Images
  FRONTEND_IMAGE: acrteam4.azurecr.io/frontend
  BACKEND_IMAGE: acrteam4.azurecr.io/backend
  IMAGE_TAG: ${{ github.sha }}

jobs:
  #########################################################
  # STAGE 1: BUILD & PUSH - Docker Images to ACR
  #########################################################
  build_push:
    name: 🐳 Build & Push Docker Images
    runs-on: ubuntu-latest
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🔐 Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 🔑 ACR Login
        run: |
          az acr login --name ${{ env.ACR_NAME }}

      - name: 🐳 Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🏗️ Build Frontend Image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}:latest
            ${{ env.FRONTEND_IMAGE }}:${{ env.IMAGE_TAG }}
          cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache,mode=max

      - name: 🏗️ Build Backend Image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:latest
            ${{ env.BACKEND_IMAGE }}:${{ env.IMAGE_TAG }}
          cache-from: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache,mode=max

      - name: ✅ Verify Images in ACR
        run: |
          echo "📦 Frontend images:"
          az acr repository show-tags --name ${{ env.ACR_NAME }} --repository frontend --output table
          echo ""
          echo "📦 Backend images:"
          az acr repository show-tags --name ${{ env.ACR_NAME }} --repository backend --output table

  #########################################################
  # STAGE 2: DEPLOY - Update AKS Deployments
  #########################################################
  deploy:
    name: 🚀 Deploy to AKS
    runs-on: ubuntu-latest
    needs: build_push
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🔐 Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ☸️ Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: 🔍 Verify Cluster Connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: 📦 Update Frontend Deployment
        run: |
          kubectl set image deployment/frontend-deployment \
            frontend=${{ env.FRONTEND_IMAGE }}:${{ env.IMAGE_TAG }} \
            -n ${{ env.AKS_NAMESPACE }}
          
          echo "✅ Frontend image updated to ${{ env.IMAGE_TAG }}"

      - name: 📦 Update Backend Deployment
        run: |
          kubectl set image deployment/backend-deployment \
            backend=${{ env.BACKEND_IMAGE }}:${{ env.IMAGE_TAG }} \
            -n ${{ env.AKS_NAMESPACE }}
          
          echo "✅ Backend image updated to ${{ env.IMAGE_TAG }}"

      - name: ⏳ Wait for Frontend Rollout
        run: |
          kubectl rollout status deployment/frontend-deployment \
            -n ${{ env.AKS_NAMESPACE }} \
            --timeout=5m
          
          echo "✅ Frontend deployment ready"

      - name: ⏳ Wait for Backend Rollout
        run: |
          kubectl rollout status deployment/backend-deployment \
            -n ${{ env.AKS_NAMESPACE }} \
            --timeout=5m
          
          echo "✅ Backend deployment ready"

      - name: 🔍 Verify Pods Status
        run: |
          echo "📊 Pod Status:"
          kubectl get pods -n ${{ env.AKS_NAMESPACE }} -o wide
          echo ""
          echo "📊 Deployment Status:"
          kubectl get deployments -n ${{ env.AKS_NAMESPACE }}

      - name: 🌐 Verify Ingress Status
        run: |
          echo "📊 Ingress Configuration:"
          kubectl get ingress -n ${{ env.AKS_NAMESPACE }}
          echo ""
          echo "📊 Services:"
          kubectl get services -n ${{ env.AKS_NAMESPACE }}

      - name: 🏥 Health Check - Backend
        run: |
          echo "🔍 Checking backend health..."
          BACKEND_POD=$(kubectl get pod -n ${{ env.AKS_NAMESPACE }} -l app=backend -o jsonpath='{.items[0].metadata.name}')
          
          if [ -n "$BACKEND_POD" ]; then
            echo "📍 Using pod: $BACKEND_POD"
            kubectl exec -n ${{ env.AKS_NAMESPACE }} $BACKEND_POD -- curl -sf http://localhost:8080/actuator/health || echo "⚠️ Health check endpoint not ready yet"
          else
            echo "⚠️ No backend pod found"
          fi
        continue-on-error: true

      - name: 🏥 Health Check - Frontend
        run: |
          echo "🔍 Checking frontend pods..."
          FRONTEND_POD=$(kubectl get pod -n ${{ env.AKS_NAMESPACE }} -l app=frontend -o jsonpath='{.items[0].metadata.name}')
          
          if [ -n "$FRONTEND_POD" ]; then
            echo "📍 Frontend pod: $FRONTEND_POD is running"
            kubectl describe pod $FRONTEND_POD -n ${{ env.AKS_NAMESPACE }} | grep -A 5 "Status:"
          else
            echo "⚠️ No frontend pod found"
          fi
        continue-on-error: true

      - name: 📝 Deployment Summary
        run: |
          echo "═══════════════════════════════════════════════════"
          echo "✅ DEPLOYMENT COMPLETED SUCCESSFULLY"
          echo "═══════════════════════════════════════════════════"
          echo ""
          echo "🌐 Application URL: http://135.220.213.50"
          echo ""
          echo "📦 Images Deployed:"
          echo "   Frontend: ${{ env.FRONTEND_IMAGE }}:${{ env.IMAGE_TAG }}"
          echo "   Backend:  ${{ env.BACKEND_IMAGE }}:${{ env.IMAGE_TAG }}"
          echo ""
          echo "☸️  Cluster: ${{ env.AKS_CLUSTER_NAME }}"
          echo "📂 Namespace: ${{ env.AKS_NAMESPACE }}"
          echo "🏷️  Image Tag: ${{ env.IMAGE_TAG }}"
          echo ""
          echo "🔗 AGIC is managing ingress routing automatically"
          echo "═══════════════════════════════════════════════════"

  #########################################################
  # STAGE 3: POST-DEPLOYMENT VALIDATION
  #########################################################
  validate:
    name: ✅ Post-Deployment Validation
    runs-on: ubuntu-latest
    needs:
      - build_push
      - deploy
    
    steps:
      - name: 🔐 Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ☸️ Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: 🔍 Validate All Resources
        run: |
          echo "🔍 Validating deployment..."
          
          # Check if all pods are running
          NOT_RUNNING=$(kubectl get pods -n ${{ env.AKS_NAMESPACE }} --field-selector=status.phase!=Running --no-headers 2>/dev/null | wc -l)
          
          if [ "$NOT_RUNNING" -gt 0 ]; then
            echo "⚠️ Warning: Some pods are not in Running state"
            kubectl get pods -n ${{ env.AKS_NAMESPACE }}
          else
            echo "✅ All pods are running"
          fi
          
          # Check ingress
          INGRESS_COUNT=$(kubectl get ingress -n ${{ env.AKS_NAMESPACE }} --no-headers 2>/dev/null | wc -l)
          echo "✅ Found $INGRESS_COUNT ingress resource(s)"
          
          # Check services
          SERVICE_COUNT=$(kubectl get services -n ${{ env.AKS_NAMESPACE }} --no-headers 2>/dev/null | wc -l)
          echo "✅ Found $SERVICE_COUNT service(s)"

      - name: 🔍 Verify AGIC Configuration
        run: |
          echo "🔍 Checking AGIC annotations on ingress..."
          kubectl describe ingress -n ${{ env.AKS_NAMESPACE }} | grep -A 10 "Annotations:" || echo "No annotations found"
          echo ""
          echo "🔍 Checking ingress class..."
          kubectl get ingress -n ${{ env.AKS_NAMESPACE }} -o jsonpath='{.items[*].spec.ingressClassName}'
        continue-on-error: true

      - name: 🌐 Test Application Endpoint
        run: |
          echo "🌐 Testing application accessibility..."
          
          # Wait a bit for AGIC to sync
          sleep 15
          
          # Test the public IP
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://135.220.213.50 || echo "000")
          
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 400 ]; then
            echo "✅ Application is accessible (HTTP $HTTP_CODE)"
          else
            echo "⚠️ Application returned HTTP $HTTP_CODE (this may be normal if the app is still initializing)"
          fi
        continue-on-error: true

      - name: 📊 Final Status Report
        if: always()
        run: |
          echo "═══════════════════════════════════════════════════"
          echo "📊 FINAL VALIDATION REPORT"
          echo "═══════════════════════════════════════════════════"
          echo ""
          kubectl get all -n ${{ env.AKS_NAMESPACE }}
          echo ""
          echo "═══════════════════════════════════════════════════"
